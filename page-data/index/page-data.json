{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"allContentfulMoztiqBlog":{"nodes":[{"id":"c57057d2-1c8e-58c3-a0c0-adc99048d0ce","title":"무기가 되는 스토리 / 도널드 밀러","slug":"building-a-storybrand-donald-miller","category":"book","releaseDate":"2024-04-10T00:00+09:00","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/71PdchmBitKXcHx37VMQi6/10468a7a31a181d95f689d3e3f2f9501/Screenshot_2024-04-10_at_7.12.35_PM.png"},"contents":{"childMarkdownRemark":{"html":"<blockquote>\n<p>웹사이트가 예쁘다고 물건이 팔리지는 않는다. 이것은 불변의 진리다. 물건을 팔아주는 것은 ‘말’이다. 우리가 분명한 메시지를 전하지 않는 한, 고객은 귀담아듣지 않는다.</p>\n</blockquote>\n<blockquote>\n<p>여러분의 메시지는 무엇인가? 입에서 술술 나오는가? 간단하면서도 마음에 와닿고 반복 가능한가? 전체 직원이 우리 회사의 메시지를 호소력 있는 방식으로 전달할 수 있는가? 우리 회사가 무엇을 제공하고 고객은 왜 그 물건을 사야만 하는지에 대한 정확한 설명 포인트가 신입사원에게까지 전달되어 있는가? 웹사이트를 방문한 고객이 우리가 뭘 제공하는지 5초 만에 파악하지 못해서 우리가 놓치고 있는 매출은 과연 얼마나 될까?</p>\n</blockquote>\n<blockquote>\n<p>여러 브랜드가 저지르는 첫 번째 실수는 그들이 제공하는 제품이나 서비스가 고객의 생존과 번창에 어떻게 도움이 되는지에 초점을 맞춰 이야기를 전개하지 못한다는 점이다.\n훌륭한 이야기는 모두 ‘생존’에 관한 것이다. 그게 어떤 종류의 생존이든 말이다. 스토리가 그 외의 다른 것을 이야기한다면 듣는 이의 마음을 사로잡지 못할 것이다. 그런 내용에는 아무도 관심이 없다. 그렇다면 앞으로 제품이나 서비스의 포지셔닝을 이런 식으로 해보면 어떨까? 사람들이 생존하고, 사랑을 찾고, 열망하는 정체성을 완성하고, 나를 물리적,사회적으로 지켜줄 집단을 형성하는 데 도움이 되는 ‘어떤 것’이라고 말이다. 그렇게 한다면 모든 이들에게 어떤 것이든 팔 수 있을 것이다. 사람들이 관심을 갖는 것은 오직 이런 것들뿐이다. 이 말은 절대적으로 믿어도 좋다.</p>\n</blockquote>\n<blockquote>\n<p>여러 브랜드가 저지르는 두 번째 실수는 고객이 그들의 제안을 이해하는 데에 너무 많은 칼로리를 소모하게 만든다는 점이다.\n어떤 정보에 너무 많은 처리 과정이 필요해 보이면 사람들은 그 쓸모없는 정보의 출처를 무시해버린다. 칼로리를 절약하기 위해서다. 다시 말해 고객들의 뇌에는 헷갈리기 시작하면 아예 무시하도록 디자인된 생존 메커니즘이 있다.</p>\n</blockquote>\n<blockquote>\n<p>사람들이 칼로리를 많이 소모하지 않아도 되게끔 정보를 구성하는 가장 강력한 툴이 바로 스토리다. 마이크의 말처럼 스토리는 ‘고개를 끄덕이게 하는 장치’다. 스토리를 어떤 포부를 가져야 하는지 알려주고, 그 포부를 달성하기 위해 싸워야 할 난관을 정의하고, 그 난관들을 정복할 계획을 제공한다. 브랜드와 관련한 스토리를 구성할 때는 고객이 따라갈 수 있는 지도를 그려서 제품이나 서비스에 관심을 갖게 만들어야 한다.</p>\n</blockquote>\n<blockquote>\n<p>노련한 작가라면 훌륭한 글의 핵심 열쇠는 ‘말하는 것’에 있지 않고 ‘말하지 않는 것’에 있음을 안다. 더 많이 잘라낼수록 더 훌륭한 시나리오, 더 훌륭한 책이 된다. 고객과 마음이 통하고 싶다면 더 이상 고객들에게 소음을 퍼붓지 말아야 한다.</p>\n</blockquote>\n<blockquote>\n<p>일단 고객이 누구인지 알고 나면, 다음은 브랜드와 관련해 고객이 원하는 게 뭔지 생각해봐야 한다. 어떤 스토리든 주인공이 무언가를 원하기 때문에 이야기가 촉발된다. 그 나머지 스토리는 주인공이 원하는 것을 얻는지 못 얻는지를 알아가는 여정에 불과하다고 해도 틀리지 않다.\n고객이 원하는 게 뭔지 알아내지 못한다면 고객은 우리가 들려주는 스토리에 초대받은 느낌이 들지 않을 것이다.</p>\n</blockquote>\n<blockquote>\n<p>해마다 수천 개의 기업이 문을 닫는다. 그들이 훌륭한 제품을 만들지 못해서가 아니다. 그 제품을 본 고객들이 그 물건이 내 삶을 어떻게 개선해줄지 이해하지 못했기 때문이다. 우리가 고객의 스토리를 구성하는 각 요소를 면밀히 분석하지 않는다면, 고객은 우리가 무관심하다고 느끼고 다른 경쟁 브랜드로 옮겨갈 것이다.</p>\n</blockquote>","excerpt":"…"}},"tag":["도널드 밀러","무기가되는스토리"]},{"id":"b0c7777f-acbf-508b-a8c6-e1fddd4afdd9","title":"Next.js (14.1.0) 캐싱에 대하여","slug":"about-next-js-14-1-caching","category":"tech","releaseDate":"2024-02-28T00:00+09:00","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/7blHDjzbOU10Z7LP1o2EHu/b2fbaa6e7e554f50070741e16b35d2c7/time-based-revalidation.avif"},"contents":{"childMarkdownRemark":{"html":"<p><a href=\"https://nextjs.org/docs/app/building-your-application/caching\">원문 Caching in Next.js</a></p>\n<p>Next.js 는 렌더링 작업 및 데이터 요청을 캐싱하여 어플리케이션 성능을 개선할 뿐만 아니라 비용을 줄여줍니다. 이 포스팅에서는 Next.js 캐싱 메커니즘과 캐싱을 구성하는데 사용할 수 있는 API, 그리고 서로 상호작용하는 방식에 대해 자세히 살펴보도록 하겠습니다.</p>\n<h3 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h3>\n<p>기본적으로 Next.js 는 성능개선과 비용절감을 위해 최대한 캐싱합니다. 선택적으로 캐시를 사용하지 않기로 결정하지 않은 한 라우트는 정적으로 렌더링되고 데이터 요청은 캐싱이 된다는 의미입니다. 아래 다이어그램은 빌드 시 라우트가 정적으로 렌더링되고 정적 라우트에 최초 진입했을 때 기본 캐싱 동작을 보여줍니다.</p>\n<p><img src=\"//images.ctfassets.net/vpyfljks33op/6fOWXjK4TmWbIhwHtDC9H3/2d2c1c0a017d991f471778bb71f29b4e/caching-overview.avif\" alt=\"caching-overview\"></p>\n<p>캐싱동작은 라우트가 어떻게 렌더링되는지 (정적, 동적), 데이터가 캐시되는지 아닌지 여부, 요청이 초기 방문의 일부인지 후속탐색의 일부인지에 따라 달라집니다. 사용 케이스에 따라 개별 라우팅과 데이터 요청에 대한 캐싱 동작을 다르게 구성할 수 있습니다.</p>\n<h3 id=\"request-memoization\" style=\"position:relative;\"><a href=\"#request-memoization\" aria-label=\"request memoization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Request Memoization</h3>\n<p>React 는 동일한 URL과 옵션을 가진 요청을 자동으로 메모이제이션하여 fetch API 를 확장합니다. React 컴포넌트 트리의 여러 곳에서 fetch 함수를 호출한다 하더라도 내부적으로는 메모이제이션하여 한번만 요청을 함으로써 동일한 데이터를 가져올 수 있다는 뜻입니다.</p>\n<p><img src=\"//images.ctfassets.net/vpyfljks33op/2ljPoYsSoyifXX4LPHayGn/a8f35a58f86cf589354bac521b402485/deduplicated-fetch-requests.avif\" alt=\"deduplicated-fetch-requests\"></p>\n<p>예를 들어, 같은 경로(예: 레이아웃, 페이지 및 여러 컴포넌트)에서 동일한 데이터를 사용해야 하는 경우 트리의 최상단에서 props 으로 하위 컴포넌트에 전달할 필요가 없습니다. 동일한 데이터를 네트워크를 통해 다중 요청하는 것에 대한 성능 영향에 대한 걱정없이 데이터를 요청할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// fetch 함수는 자동으로 결과를 메모하고 캐시합니다.</span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://.../item/1'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// getItem 함수는 두번 요청되지만 한번 실행됩니다.</span>\n<span class=\"token keyword\">const</span> item <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// cache MISS (cache 에 없는 상태)</span>\n\n<span class=\"token comment\">// 두번째 요청은 같은 경로의 어디에서든 가능합니다.</span>\n<span class=\"token keyword\">const</span> item <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// cache HIT (cache 에 있는 상태)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>Request Memoization 이 동작하는 법</strong></p>\n<p><img src=\"//images.ctfassets.net/vpyfljks33op/1RpPYWHTNOXIx8mmx4Sb7p/3c893745a13e66c3ba72459e8825108a/request-memoization.avif\" alt=\"request-memoization\"></p>\n<ol>\n<li>경로가 렌더링 되는 동안 특정 요청이 처음 호출되면 그 결과는 메모리에 있지 않고 cache MISS 상태일 것입니다.</li>\n<li>그러므로 함수는 실행이 되고 외부소스에서 데이터를 가져와서 메모리에 저장합니다.</li>\n<li>동일한 경로에서 같은 함수가 요청이 되면 cache HIT 상태이므로 함수를 실행하지 않고 메모리로 부터 데이터를 전달받습니다.</li>\n<li>경로가 렌더링 되고 렌더링 패스 (화면에 구성요소가 그려지는 과정) 가 완료되면 메모리는 리셋되고 모든 요청 메모이제이션 항목이 지워집니다.</li>\n</ol>\n<blockquote>\n<p><strong>알아두면 좋아요</strong></p>\n<ul>\n<li>Request Memoization 은 Next.js 가 아닌 React 의 기능입니다. 다른 캐싱 메커니즘과 어떻게 상호작용하는지 보여주기 위해 여기에 포함시켰습니다.</li>\n<li>Memoization 은 fetch 요청의 GET 메소드에만 적용됩니다.</li>\n<li>Memoization 은 React 컴포넌트 트리에만 적용됩니다. generateMetadata, generateStaticParams, Layouts, Pages, 그리고 Server Components 에는 적용되지만 React 컴포넌트 트리의 일부가 아닌 Router Handler 에는 적용되지 않습니다.</li>\n<li>fetch 가 적합하지 않은 경우 (일부 Database, CMS Clients, GraphQL clients 등) React cache function 으로 함수를 메모할 수 있습니다.</li>\n</ul>\n</blockquote>\n<h4 id=\"duration\" style=\"position:relative;\"><a href=\"#duration\" aria-label=\"duration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Duration</h4>\n<p>캐시는 React component tree 렌더링이 끝나는 서버요청 수명동안 지속합니다.</p>\n<h4 id=\"revalidating\" style=\"position:relative;\"><a href=\"#revalidating\" aria-label=\"revalidating permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Revalidating</h4>\n<p>Memoization 은 서버요청 간에 공유되지 않고 렌더링되는 동안만 적용이 되기때문에 revalidate 할 필요가 없습니다.</p>\n<h4 id=\"opting-out\" style=\"position:relative;\"><a href=\"#opting-out\" aria-label=\"opting out permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Opting out</h4>\n<p>fetch 요청에서 memoization 을 하지 않기 위해서는 <code class=\"language-text\">AbortController signal</code> 을 요청에 넘기면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> signal <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AbortController</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> signal <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"data-cache\" style=\"position:relative;\"><a href=\"#data-cache\" aria-label=\"data cache permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Data Cache</h3>\n<p>Next.js 는 서버 요청, 배포를 통해 들어오는 데이터 결과를 유지하는 Data Cache 가 내장되어 있습니다. 이는 Next.js 가 native fetch API 를 확장하여 서버 상의 각 요청이 자체 영구 캐싱 규칙을 설정할 수 있게 함으로써 가능합니다.</p>\n<blockquote>\n<p><strong>알아두면 좋아요</strong>\n브라우저에서 fetch 의 cache 옵션은 어떻게 요청이 브라우저의 HTTP cache 와 상호작용할지를 지시하지만 Next.js 에서는 어떻게 서버측 요청이 서버의 Data Cache 와 상호작용할지를 지시합니다.</p>\n</blockquote>\n<p>기본적으로 fetch 를 사용하는 데이터 요청은 캐시처리됩니다. cache 나 next.revalidate 옵션으로 캐시 동작을 구성할 수도 있습니다.</p>\n<p><strong>How the Data Cache Works</strong></p>\n<p><img src=\"//images.ctfassets.net/vpyfljks33op/1fIVRqqJXoIgT8TB08yww4/bd8b0468d5105efe2575ab3740004d46/data-cache.avif\" alt=\"data-cache\"></p>\n<ol>\n<li>렌더링되는 동안 최초로 fetch 요청이 호출되면 Next.js 는 Data Cache 에서 캐시된 응답이 있는지 확인합니다.</li>\n<li>캐시된 응답이 확인되면 즉시 반환되고 메모합니다.</li>\n<li>캐시된 응답이 발견되지 않으면 데이터 소스에 요청해 결과를 Data Cache 에 저장 후 메모합니다.</li>\n<li>캐시되지 않은 데이터가 필요하다고 설정할 경우 (e.g {cache: 'no-store'}) 결과는 항상 데이터소스에서 가져와 메모합니다.</li>\n<li>데이터가 캐시되든, 캐시되지 않든 요청은 항상 메모하여 React 렌더링 패스가 진행되는 동안 동일한 데이터에 대한 중복요청을 피할 수 있습니다.</li>\n</ol>\n<blockquote>\n<p><strong>Data Cache 와 Request Memoization 의 차이점</strong>\n두 캐싱 메커니즘 모두 캐시된 데이터를 재사용하여 성능을 개선하지만 Data Cache 는 들어오는 요청과 배포를 걸쳐 영구적이며, Request Memoization 은 요청의 수명동안만 지속됩니다.\nMemoization 으로 동일한 렌더링 패스 안에서 렌더링 서버에서 Data Cache 서버 (e.g. CDN, Edge) 나 데이터 소스 (e.g. database, CMS) 로의 네트워크를 통한 중복 요청의 수를 줄일 수 있고 Data Cache 로 원본 데이터 소스에 대한 요청의 수를 줄일 수 있습니다.</p>\n</blockquote>\n<h4 id=\"duration-1\" style=\"position:relative;\"><a href=\"#duration-1\" aria-label=\"duration 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Duration</h4>\n<p>Data Cache 는 revalidate 하거나 사용하지 않겠다고 선택하지 않는 이상 들어오는 요청과 배포에 걸쳐 영구적입니다.</p>\n<h4 id=\"revalidating-1\" style=\"position:relative;\"><a href=\"#revalidating-1\" aria-label=\"revalidating 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Revalidating</h4>\n<p>캐시된 데이터는 두가지 방식으로 재검증할 수 있습니다.</p>\n<ul>\n<li><strong>Time-based Revalidation:</strong> 일정 시간이 지난 후 새로운 요청이 이루어지면 데이터를 재검증합니다. 자주 변경되지 않거나 최신 데이터의 중요도가 낮은 경우에 유용합니다.</li>\n<li><strong>On-demand Revalidation:</strong> 이벤트 기반으로 데이터를 재검증합니다. (e.g. form submission) On-demand revalidation 은 태그 기반, 경로 기반 방식으로 한번에 그룹 데이터를 재검증할 때 사용할 수 있습니다. 가능한한 최신 데이터를 원할 때 유용합니다. (e.g. headless CMS 의 내용이 업데이트 될 때)</li>\n</ul>\n<p><strong>Time-based Revalidation</strong></p>\n<p>일정한 시간 간격으로 재검증하기 위해 fetch 함수의 next.revalidate 옵션으로 리소스의 캐시 수명(초단위)을 지정할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// Revalidate at most every hour</span>\n<span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://...'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">next</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">revalidate</span><span class=\"token operator\">:</span> <span class=\"token number\">3600</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또는 특정 세그먼트 내의 모든 fetch 요청을 구성하거나 fetch 를 사용할 수 없는 경우 Route Segment Config options 을 사용할 수 있습니다.</p>\n<p><strong>Time-based Revalidation 동작 방식</strong></p>\n<p><img src=\"//images.ctfassets.net/vpyfljks33op/7blHDjzbOU10Z7LP1o2EHu/b2fbaa6e7e554f50070741e16b35d2c7/time-based-revalidation.avif\" alt=\"time-based-revalidation\"></p>\n<ol>\n<li>revalidate 로 최초 fetch 요청을 하면 외부 데이터소스에서 가져온 데이터가 Data Cache 에 저장됩니다.</li>\n<li>지정한 시간 내의 모든 요청은 캐시된 데이터를 반환합니다.</li>\n<li>지정한 시간 이후의 다음 요청도 여전히 캐시된 데이터 (now stale) 를 반환합니다.</li>\n<li>Next.js 는 백그라운드에서 데이터검증을 작동시킵니다.</li>\n<li>데이터를 성공적으로 가져오면 Next.js 는 신규 데이터로 Data Cache 를 갱신합니다.</li>\n<li>백그라운드 재검증이 실패하면 이전 데이터는 변경되지 않은 상태로 유지됩니다.</li>\n</ol>\n<p>위의 동작은 stale-while-revalidate 와 유사합니다.</p>\n<p><strong>On-demand Revalidation</strong></p>\n<p>데이터는 경로 (revalidatePath) 나 캐시 태그 (revalidateTag) 기반의 온디맨드 방식으로 재검증할 수 있습니다.</p>\n<p><strong>On-Demand Revalidation 동작 방식</strong></p>\n<p><img src=\"//images.ctfassets.net/vpyfljks33op/6uJYlkpjNKQ1caXhrSIQ6Z/7557c7fbc2f43f2b695c55bed2f37bb0/on-demand-revalidation.avif\" alt=\"on-demand-revalidation\"></p>\n<ol>\n<li>최초 fetch 요청이 호출되면 데이터를 외부에서 가져와 Data Cache 에 저장합니다.</li>\n<li>On-demand revalidation 이 작동하면 해당 캐시 항목이 캐시에서 제거됩니다. Time-based revalidation 과 다르게 동작합니다.</li>\n<li>다음 요청에서 캐시가 발견되지 않아 (cache MISS) 데이터를 외부에서 가져와 Data Cache 에 저장합니다.</li>\n</ol>\n<h4 id=\"opting-out-1\" style=\"position:relative;\"><a href=\"#opting-out-1\" aria-label=\"opting out 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Opting out</h4>\n<p>개별 데이터 요청의 cache 옵션을 no-store 로 지정할 수 있습니다. 이렇게 되면 fetch 가 호출될 때마다 데이터를 데이터 소스에서 가져옵니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// Opt out of caching for an individual `fetch` request</span>\n<span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">https://...</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">cache</span><span class=\"token operator\">:</span> <span class=\"token string\">'no-store'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또한 특정한 경로 세그먼트에 대해 캐싱하지 않으려면 Route Segment Config options 을 사용할 수 있습니다. 이렇게 하면 타사 라이브러리를 포함하여 경로 세그먼트의 모든 데이터 요청에 영향을 미칩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// Opt out of caching for all data requests in the route segment</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> dynamic <span class=\"token operator\">=</span> <span class=\"token string\">'force-dynamic'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<blockquote>\n<p><strong>Vercel Data Cache</strong>\nNext.js 애플리케이션이 Vercel에 배포된 경우 Vercel Data Cache 문서를 통해 Vercel 특정 기능에 대해 더 잘 이해하는 것이 좋습니다.</p>\n</blockquote>\n<h3 id=\"full-route-cache\" style=\"position:relative;\"><a href=\"#full-route-cache\" aria-label=\"full route cache permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Full Route Cache</h3>\n<blockquote>\n<p><strong>관련 용어</strong>\nAutomatic Static Optimization, Static Site Generation, Static Rendering 이라는 용어는 빌드 시 어플리케이션의 라우트를 렌더링하고 캐싱하는 프로세스를 언급할 때 혼용해서 사용될 수 있습니다.</p>\n</blockquote>\n<p>Next.js 는 빌드시점에 자동으로 라우트를 렌더링하고 캐싱합니다. 매 요청마다 서버에서 렌더링하는 대신 캐싱한 라우트를 제공하도록 최적화하여 페이지를 좀 더 빠르게 로딩할 수 있도록 합니다.</p>\n<p>Full Route Cache 가 어떻게 동작하는지 이해하기 위해서 React 가 렌더링을 어떻게 다루는지, Next.js 가 렌더링 결과를 어떻게 캐싱하는지를 살펴보는 것이 도움이 됩니다.</p>\n<h4 id=\"1-react-rendering-on-the-server\" style=\"position:relative;\"><a href=\"#1-react-rendering-on-the-server\" aria-label=\"1 react rendering on the server permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. React Rendering on the Server</h4>\n<p>서버에서 Next.js 는 React API 를 사용하여 렌더링을 조율합니다. 렌더링 작업은 개별 라우트 세그먼트와 Suspense 경계에 의해 chunk 로 분할됩니다.</p>\n<p>각 chunk 는 두 단계로 렌더링됩니다.</p>\n<ol>\n<li>React 는 서버 컴포넌트를 스트리밍에 최적화된 특수한 데이터 포맷으로 렌더링하는데 이를 <em>React Server Component Payload</em> 라고 합니다.</li>\n<li>Next.js 는 React Server Component Payload 와 Client Component Javascript instructions 를 서버에서 HTML 을 렌더링하기 위해 사용합니다.</li>\n</ol>\n<p>이는 모든 작업이 렌더링될 때까지 기다릴 필요없이 응답을 스트리밍할 수 있다는 의미입니다.</p>\n<blockquote>\n<p><strong>React Server Component Payload 란?</strong>\nReact Server Component Payload 는 렌더링된 React Server Components tree 의 압축된 바이너리 형태입니다. React Client 에서 브라우저 DOM 을 업데이트하기 위해 사용됩니다. 다음을 포함하고 있습니다.</p>\n<ul>\n<li>Server Component 의 렌더링된 결과</li>\n<li>클라이언트 컴포넌트가 렌더링될 위치에 대한 placeholder 와 해당 자바스크립트 파일에 대한 참조</li>\n<li>Server Component 에서 Client Component 로 전달된 props</li>\n</ul>\n</blockquote>\n<h4 id=\"2-nextjs-caching-on-the-server-full-route-cache\" style=\"position:relative;\"><a href=\"#2-nextjs-caching-on-the-server-full-route-cache\" aria-label=\"2 nextjs caching on the server full route cache permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Next.js Caching on the Server (Full Route Cache)</h4>\n<p><img src=\"//images.ctfassets.net/vpyfljks33op/7JGFaKDKaleuHsAPSFLpG3/893f138a190e0cc4e98129c73f1dff57/full-route-cache.avif\" alt=\"full-route-cache\"></p>\n<p>Next.js 에서는 서버 상에서 라우트를 렌더링한 결과 (React Server Component Payload and HTML) 를 캐싱하는 것이 기본 동작입니다. 빌드시에 정적으로 렌더링된 라우트나 재검증중인 경로에 적용됩니다.</p>\n<h4 id=\"3-react-hydration-and-reconciliation-on-the-client\" style=\"position:relative;\"><a href=\"#3-react-hydration-and-reconciliation-on-the-client\" aria-label=\"3 react hydration and reconciliation on the client permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. React Hydration and Reconciliation on the Client</h4>\n<p>요청 시에 클라이언트에서는 ..</p>\n<ol>\n<li>HTML 은 Client, Server Components 의 상호작용이 없는 초기 화면을 즉시 표시하는 데 사용됩니다.</li>\n<li>React Server Components Payload 는 Client 와 렌더링된 Server Component trees 를 조정하고 DOM 을 갱신하는 데 사용됩니다.</li>\n<li>JavaScript instructions 는 Client Components 를 활성화 (hydrate) 해서 어플리케이션이 상호작용할 수 있도록 합니다.</li>\n</ol>\n<h4 id=\"4-nextjs-caching-on-the-client-router-cache\" style=\"position:relative;\"><a href=\"#4-nextjs-caching-on-the-client-router-cache\" aria-label=\"4 nextjs caching on the client router cache permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Next.js Caching on the Client (Router Cache)</h4>\n<p>React Server Component Payload 는 클라이언트 측 Router Cache (개별 라우트 세그먼트에 의해 분할 된 인메모리 캐시) 에 저장됩니다. Router Cache 는 이전에 방문한 경로와 프리페칭된 라우트를 저장해서 탐색 경험을 향상시킵니다.</p>\n<h4 id=\"5-subsequent-navigations\" style=\"position:relative;\"><a href=\"#5-subsequent-navigations\" aria-label=\"5 subsequent navigations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Subsequent Navigations</h4>\n<p>이후의 탐색이나 프리페칭 중에 Next.js 는 React Server Components Payload 가 Router Cache 에 저장되어 있는지 확인해서 있다면 서버에 새로운 요청을 보내지 않습니다. 라우트 세그먼트가 캐시에 없는 경우 Next.js 는 서버에서 React Server Components Payload 를 가져와서 클라이언트 Router Cache 에 채웁니다.</p>\n<h4 id=\"static-and-dynamic-rendering\" style=\"position:relative;\"><a href=\"#static-and-dynamic-rendering\" aria-label=\"static and dynamic rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static and Dynamic Rendering</h4>\n<p>라우트가 빌드 시에 캐시될지 아닐지는 정적, 동적 렌더링 여부에 달려있습니다. 기본적으로 정적 라우트는 캐시하고 반면에 동적 라우트는 요청 시에 렌더링 되며 캐시되지 않습니다.\n아래 다이어그램은 캐시된 데이터와 캐시되지 않은 데이터를 사용하여 정적으로 렌더링된 라우트와 동적으로 렌더링된 라우트의 차이를 보여줍니다</p>\n<p><img src=\"//images.ctfassets.net/vpyfljks33op/1HYj3Zp3EqvkfW4SH78272/c2b1b3833d8d854411a2cb54a630a924/static-and-dynamic-routes.avif\" alt=\"static-and-dynamic-routes\"></p>\n<h4 id=\"duration-2\" style=\"position:relative;\"><a href=\"#duration-2\" aria-label=\"duration 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Duration</h4>\n<p>기본적으로 Full Route Cache 는 영구적으로 지속됩니다. 렌더링 결과물이 사용자의 요청으로 캐시된다는 의미입니다.</p>\n<h4 id=\"invalidation\" style=\"position:relative;\"><a href=\"#invalidation\" aria-label=\"invalidation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Invalidation</h4>\n<p>Full Route Cache 를 무효화할 수 있는 두가지 방법이 있습니다.</p>\n<ul>\n<li>Revalidating Data: Data Cache 를 재검증하여 서버에서 컴포넌트를 다시 렌더링하고 새로운 렌더링 출력을 캐싱함으로써 Router Cache 를 무효화합니다.</li>\n<li>Redeploying: 배포간에 지속되는 Data Cache 와 다르게 Full Route Cache 는 신규 배포시 초기화됩니다.</li>\n</ul>\n<h4 id=\"opting-out-2\" style=\"position:relative;\"><a href=\"#opting-out-2\" aria-label=\"opting out 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Opting out</h4>\n<p>Full Route Cache 를 선택하지 않는 법, 다시 말해 들어오는 매 요청마다 동적으로 컴포넌트를 렌더링 하는 법은 다음과 같습니다.</p>\n<ul>\n<li>Dynamic Function 사용: 이렇게 하면 Full Route Cache 에서 경로를 선택 해제하고 요청 시점에 동적으로 렌더링합니다. Data Cache 는 계속 사용할 수 있습니다.</li>\n<li>dynamic = 'force-dynamic' or revalidate = 0 route segment config options: 이렇게 하면 Full Route Cache 와 Data Cache 를 건너뜁니다. 즉, 서버로 들어오는 모든 요청에 대해 컴포넌트가 렌더링되고 데이터를 가져옵니다. Router Cache 는 클라이언트 측 캐시이므로 계속 적용됩니다.</li>\n<li>Data Cache 사용하지 않기: 캐시되지 않은 라우트 요청이 있는 경우 Full Route Cache 에서 해당 경로를 제외합니다. 특정 요청에 대한 데이터는 모든 요청에 대해 fetch 됩니다. 캐싱하도록 설정된 요청은 여전히 데이터 캐시에 캐시됩니다. 이렇게 하면 캐시된 데이터와 캐시되지 않은 데이터를 혼합하여 사용할 수 있습니다.</li>\n</ul>","excerpt":"원문 Caching in Next.js Next.js 는 렌더링 작업 및 데이터 요청을 캐싱하여 어플리케이션 성능을 개선할 뿐만 아니라 비용을 줄여줍니다. 이 포스팅에서는 Next.js 캐싱 메커니즘과 캐싱을 구성하는데 사용할 수 있는 API…"}},"tag":["Nextjs","Caching"]},{"id":"2feb3b65-c878-515c-ba16-dd5b96247260","title":"타이탄의 도구들 - 언제나 가능한 것을 시작하라 (케이시 네이스탯 편)","slug":"tools-of-the-titan-always-start-with-whats-possible-by-casey-neistat","category":"book","releaseDate":"2024-02-27T00:00+09:00","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/2tdFjwXUKVthYWcggOennK/9aced5e340200859036905dab1ce4282/Screenshot_2024-02-06_at_12.50.55_PM.png"},"contents":{"childMarkdownRemark":{"html":"<blockquote>\n<p>케이시 네이스탯<em>Casey Neistat, @CaseyNeistat</em> 은 뉴욕을 무대로 활동하는 영화 제작자이자 가장 영향력 있는 유튜버다. 그의 온라인 영화는 지난 5년 동안 3억 회에 가까운 조회 수를 기록했다. 그는 작가, 감독, 편집자이자 HBO에서 방영한 &#x3C;네이스탯 브라더스<em>The Neistat Brothers</em>> 시리즈에 출연한 스타이고, 2011년에는 영화 &#x3C;키다리 아저씨<em>Daddy Longlegs</em>>로 인디펜던트 스피릿 어워드<em>Independent Spirit Awards</em>에서 존 카사베츠 상<em>John Cassavetes Award</em>을 받기도 했다. 그의 작품들은 인터넷에서만 독점 공개되며 대부분 단편 영화들이다. 하지만 공개될 때마다 평론가와 관객들의 극찬을 불러 모았다. 나아가 그는 아주 간단한 동영상 제작과 공유를 목표로 하는 스타트업 기업인 빔<em>Beme</em>의 설립자이기도 하다.</p>\n<p><strong>당신의 분노를 따라가라</strong>\n케이시를 스타 반열에 올린 작품은 2011년에 그가 만든 &#x3C;자전거 전용도로<em>Bike Lanes</em>>라는 단편 영화였다. 그의 실제 경험에 바탕한 이 영화는 입소문을 타고 폭발적인 인기를 불러 모았다.\n케이시는 자전거 전용도로가 아닌 곳에서 자전거를 탔다는 이유로 뉴욕 경찰에게 소환장을 받았을 때 화가 머리끝까지 치밀어 올랐다. 하지만 그는 법원에 출두해 50달러짜리 소환장 때문에 한나절 동안 싸우며 시간을 허비하는 대신, 자신의 분노 방향을 다른 쪽으로 돌려 그것을 영리한 방법으로 표현한 영화를 만들었다.\n케이시는 경찰이 자신에게 한 말을 관객들에게 되풀이하면서 영화를 시작한다. '자전거 운전자는 안전과 법적인 이유 때문에 반드시 자전거 전용도로로만 다녀야 한다.'\n그는 자전거를 타고 뉴욕 시 여기저기를 돌아다니면서 사람들이 이 규칙을 지키지 못하게 만드는 자전거 전용도로 내의 온갖 시설물과 충돌한다. 이 영화의 클라이맥스는 케이시가 자전거 전용도로 한복판에 주차되어 있는 경찰차와 충돌하는 장면이다.\n관객들의 반응은 상상을 초월했다. 공개 첫날에만 500만 건의 조회 수를 기록했다. 마침내 마이클 블룸버그<em>Michael Bloomberg</em> 뉴욕 시장이 기자회견을 열어 이 영화에 담긴 질문들에 답하고 적절한 조치와 개선을 약속해야 했다.\n케이시는 이렇게 말했다. \"어떤 창조적인 프로젝트를 하는 게 좋을지 잘 모를 때가 있는가? 그때는 자신의 분노를 따라가 보라. 내가 그랬던 것처럼 소득이 있을 것이다.\"\n맥도날드 햄버거만 30일 동안 하루 세 끼 직접 먹는 체험을 통해 비만사회와 패스트푸드 기업에 일침을 날린 다큐멘터리 &#x3C;슈퍼사이즈 미>의 모건 스펄록<em>Morgan Spurlock</em> 감독 또한 세상을 바꿀 만한 것을 만들려면 세상의 분노 속으로 직접 들어가야 한다고 강조한 바 있다. &#x3C;슈퍼사이즈 미>는 세계적으로 큰 반향을 불러 일으켰고 아카데미 상 다큐멘터리 부분 후보에 오르는 등 큰 성공을 거두었다. 미국 최고의 코미디언이자 배우이자 작가인 휘트니 커밍스<em>Whitney Cummings</em> 또한 이렇게 말한 바 있다. \"뭔가가 당신을 불쾌하게 한다면, 그 안을 들여다봐라. 무언가 있다는 신호다.\"</p>\n<p><strong>당신이 할 수 있는 가장 충격적인 일은?</strong>\n유튜브에서만 2,000만 명 이상이 관람한 동영상 &#x3C;가치 있는 순간을 만들어라<em>Make It Count</em>> 에는 케이시의 성공 비결이 함축적으로 담겨 있다.\n2011년 케이시는 그 재능을 인정받아 광고계에서 성공적인 경력을 쌓아가고 있었다. 하지만 그의 표현을 빌리자면 '말할 수 없이 따분한' 시기이기도 했다. 그는 당시 나이키<em>Nike</em> 와 3건의 광고 계약을 맺고 있었다. 그가 처음 만든 두 편은 안정적인 성공을 거뒀다. 몸값이 1억 달러에 달하는 거물급 운동선수들이 출연했기 때문에 고객들의 반응이 매우 좋았다. 그런데 세 번째 광고를 제작할 때에 이르자 그는 갑자기 몹시 지루하고 피곤한 감정을 느꼈다. 앞에서 거둔 성공을 무심코 흉내 내다 보면 순식간에 삼류감독으로 전락할 것 같았다. 그는 나이키 광고 담당자에게 전화를 걸었다. \"이봐요, 1~2편처럼 가는 건 너무 지루하지 않아요? 때려치웁시다. 대신 내가 늘 하고 싶었던 걸 해볼게요. 광고 제작 예산이 다 떨어질 때까지 무작정 세상을 돌아다니며 그 과정을 기록해볼게요. 그러면 그에 대한 영상도 만들 수 있을 겁니다.\" 그러자 담당자는 이렇게 말하며 전화를 끊었다. \"당신, 미쳤군요. 하지만 좋아요.\"\n나이키가 손을 들어준 미친 감독의 영화 &#x3C;가치 있는 순간을 만들어라>는 이렇게 탄생했다. 영화는 다음과 같은 자막으로 시작된다. \"나이키는 내게 가치 있는 순간을 만든다는 게 어떤 의미인지에 대한 영상을 만들어달다고 부탁했다. 나는 그들을 위한 영화를 만드는 대신, 오직 나 자신에게 가치 있는 순간을 만들기 위해 친구 맥스와 함께 세계를 돌아다니며 제작비를 다 썼다. 우리는 돈이 떨어질 때까지 돌아다녔다. 총 10일 동안 15개 나라를 돌아다녔다…\"\n'타인이 아니라 나에게 중요한 것을 따라가라'는 메시지를 담은 이 영상은 메가 히트했다. 광고 영상의 공식과 판도를 송두리째 뒤엎어버렸고, 지난 몇 년 동안 지구상의 모든 메시지와 캠페인의 방식을 혁신적으로 바꿔놓았다.</p>\n<p><strong>언제나 가능한 것은 무엇인가?</strong>\n케이시는 15살에 가출해 17살에 한 아이의 아빠가 되었다. 생활보호대상자로 지정되어 분유와 기저귀 값을 지원받는 어린 가장이었다. 이처럼 일찍부터 시련과 불우함의 연속이었던 그는 어떻게 자신의 삶을 가장 혁신적인 방식으로 바꿀 수 있었을까? 이 궁금증에 대한 그의 답은 진짜 멋지다. \"가치 있는 일을 할 때 우리는 바뀐다. 그러면 가치 있는 일을 하려면 어떻게 해야 할까? '가능한 일'을 해야 한다. 우리는 곧 자기가 주변에서 가장 잘 생긴 사람이 될 수 없다는 걸 깨닫게 된다. 가장 똑똑한 사람도 될 수 없고, 가장 교양 있거나 조예가 깊은 사람이 되는 것도 불가능하다. 그런 면에서는 남들과 경쟁할 수 없다. 하지만 언제나 경쟁이 가능한, 성공에 있어서 진정으로 평등한 측면이 하나 있다. 바로 '노력'이다. 옆에 있는 사람보다 더 열심히 노력하는 건 언제나 가능하기 때문이다.\"\n우리는 우리가 좋아하는 일에 더 많은 시간을 쓰려고 노력한다. 흠, 정말 그럴까? 원하는 일에 더 많은 시간을 내는 것은, 싫어하는 일을 하는 데 얼마나 더 적은 시간을 썼느냐가 결정한다. 그런데 생각해보라. 하루 종일 싫어하는 일을 하는 데 매달려 있지는 않은가? 케이시가 말하는 진정한 노력의 의미와 방향이 여기에 있다. 매달려 있는 것과 노력은 전혀 다른 차원이다. 역설적으로 들리겠지만, 좋아하는 일을 하는 데 시간을 많이 내는 것은 불가능하다. 하지만 싫어하는 일을 빨리 해치우는 건 노력을 통해 가능하다. 우리는 가능한 것을 해야 한다. 이것이 곧 불가능해 보이는 일에 접근 가능한 유일한 방법이다.\n케이시는 싫어하는 일의 목록을 지워나가는 노력을 기울였다. 그러다 보니 '가치 있는 순간'을 만드는 것이야말로 자신이 가장 좋아하는 일이라는 것을 발견했다. 처음부터 자신이 원하는 일, 좋아하는 일을 알고 있는 사람은 없다.\n케이시는 위대한 현자 벤저민 프랭클린의 다음과 같은 탁월한 조언을 등불 삼아 따라간 사람일 것이다. \"죽어서 육신이 썩자마자 사람들에게 잊히고 싶지 않다면, 읽을 만한 가치가 있는 글을 쓰든지, 글로 남길 만한 가치가 있는 일을 하라.\"\n훗날 그는 분명 자신이 사랑하는 일만 하다 떠난 우리 시대 가장 성공한 사람으로 기억될 것이다. 하지만 이와 동시에 정작 그가 한 일은, 싫어하는 일을 하는 데 가장 적인 시간을 쓰려고 노력한 것뿐임을 기억해야 한다.\n이 두가지 기억의 미묘한 차이를 분명히 알아차릴 때 당신의 인생 또한 새로운 방식으로 변화해 나갈 것이다.</p>\n</blockquote>\n<p><a href=\"https://www.youtube.com/watch?v=bzE-IMaegzQ\">케이시 네이스탯의 자전거 전용도로Bike Lanes</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=WxfZkMm3wcg\">케이시 네이스탯의 가치 있는 순간을 만들어라Make It Count</a></p>","excerpt":"케이시 네이스탯Casey Neistat, @CaseyNeistat 은 뉴욕을 무대로 활동하는 영화 제작자이자 가장 영향력 있는 유튜버다. 그의 온라인 영화는 지난 5년 동안 3억 회에 가까운 조회 수를 기록했다. 그는 작가, 감독, 편집자이자 HBO…"}},"tag":["타이탄의도구들","케이시네이스탯"]},{"id":"fdc405b9-600a-57a7-a8e2-4634fe6c337e","title":"타이탄의 도구들 - 모든 것을 기록으로 남겨라 (마이크 버비글리아 편)","slug":"tools-of-the-titan-keep-a-record-of-everything-with-mike-birbiglia","category":"book","releaseDate":"2024-02-17T00:00+09:00","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/2tdFjwXUKVthYWcggOennK/9aced5e340200859036905dab1ce4282/Screenshot_2024-02-06_at_12.50.55_PM.png"},"contents":{"childMarkdownRemark":{"html":"<blockquote>\n<p>마이크 버비글리아<em>Mike Birbiglia, @birbigs</em>는 카메라 앞에서나 밖에서나, 세상에서 가장 바쁜 사람이다. 연극과 영화, 스토리텔링, 스탠드업 코미디가 합쳐진 그의 솔로 투어 공연은 전 세계에서 매진을 기록한다. 최근에는 제작, 감독, 각본, 주연을 맡은 영화 &#x3C;돈 싱크 트와이스<em>Don't think twice</em>>로 평단과 관객의 찬사를 얻은 바 있다.</p>\n<p><strong>마이크!!! 너하고 약속이 있어</strong>\n마이크는 상대를 움직이게 하는 힘을 갖고 있다. 더 놀라운 건 '자기 자신'을 자신의 뜻대로 움직이게 하는 데도 일가견이 있다는 것이다. 그 비결에 대해 들어보자.\n\"내게는 지금껏 사람들에게 공개하지 않은 독특한 습관이 있다. 언젠가 천천히 나를 돌아보니, 자꾸만 미루는 버릇이 있었다. 사람들과의 약속을 미루는 법은 없었다. 그런데 운동을 하겠다거나 글을 규칙적으로 쓰겠다는 등 내 자신과의 약속은 언제나 뒷전으로 밀려나고 밀려나다가 나중엔 흐지부지되고 있었다. 문득 '내 자신도 내가 못 움직이는데, 다른 사람을 내 뜻대로 움직여보겠다고? 너무 한심하군!' 하는 생각이 들었다. 그래서 그날 밤부터 나는 '마이크!!!(느낌표의 개수도 중요하다) 내일 아침 7시에 페들러 카페(내가 주로 글을 쓰고 사색을 하는 장소)에서 너하고 약속이 있어!'라고 적은 쪽지를 침대 옆에 두고 잤다. 바보 같고 창피한 얘기처럼 들리겠지만, 효과가 컸다.\"\n내가 이 책에서 마이크 버비글리아를 소개하는 가장 큰 이유가 여기에 있다. 다른 사람과의 약속처럼 자기 자신과의 약속 또한 명확하게 '시각화'해서 상기시키면 실행력이 매우 높아진다. 머릿속으로만 생각하거나 휴대폰 알람 메시지로 만들지 말고, 손으로 직접 쓴 쪽지를 자신에게 주어라. 이 작은 노력 하나로 마이크 버비글리아는 배우들 사이에서 가장 자기관리를 잘하는 사람으로 평가받았다. 페들러 카페에서 만나기로 한 자신과의 약속을 잘 지킨 그는 배우들 사이에서 가장 대본을 잘 쓰는 작가라는 명성도 얻었다.</p>\n<p><strong>모든 것을 기록하라</strong>\n마이크는 젊은 팬들을 만날 때마다 '모든 것을 기록해두라'는 조언을 아끼지 않는다. 시간은 빠르게 사라지고 모든 일은 구름처럼 흘러간다. 그 찰나의 순간들 속에 우리가 얻어야 할 인생의 영감과 힌트, 단서들이 담겨 있다. 이것들을 놓치지 않는 유일한 방법은 '기록'이다. 그는 이렇게 말했다. \"아무리 강조해도 지나치지 않은 게 있다. 일기를 쓰라는 것이다. 단 다름 사람들과는 좀 다르게 써라. 많은 사람들이 쓰는 방식에서 벗어나라는 것이다. 나만의 호흡으로 써라. 어떤 하루에 대한 기록은 책 한 권의 분량이 나올 수도 있고, 한 단어나 한 줄로 정리되는 하루도 있을 것이다. 절대 정해진 양을 채우려고 아등바등하지 마라. '표준'이나 '기준'에 굴복하지 말라는 뜻이다. 그래야 진짜 한 걸음 더 나간다. 한 걸음 더 나가서 남들에게 절대 보여주지 않을 것 같은 얘기를 일기장에 담아라. 그것들이 결국 언젠가 세상에 공개되면서부터 당신은 점점 명성을 얻어나가게 될 것이다.\"\n이쯤 되면 '표준<em>standard</em>을 거부하라'는 메시지는 성공과 부, 지혜를 얻는 가장 기본적인 진리로 자리 잡는 것 같다. 이 책의 타이탄들 모두 입이 아프게 강조하니까 말이다. 강박적인 노트 수집가로서 나 또한 당신에게 단 하나의 조언을 주자면, 모든 걸 기록하라고 하겠다. 기록의 힘은 강력하다. 그리고 무엇보다 어렵지 않다. 가장 들이기 좋은 습관이다.\n마이크는 마지막으로 이렇게 말했다. \"자신을 더 많이 알리는 데 시간을 낭비하지 마라. 그 시간에 더 많이 알릴 수 있는 '능력'을 키워라. 단순히 잘하는<em>good</em> 사람이 아니라 위대한<em>great</em> 사람이 되려고 노력해야 한다. 나이가 들수록 점점 뚜렷하게 깨닫게 된다. 이 세상에는 정말 똑똑하고 능력 있는 사람은 많지만, 자신의 일에 영혼까지 쏟아 붓는 위대한 사람은 별로 없다는 사실을.\"</p>\n</blockquote>","excerpt":"마이크 버비글리아Mike Birbiglia, @birbigs…"}},"tag":["타이탄의도구들","마이크버비글리아"]},{"id":"8c55ce00-e490-5c65-aaee-24fff5cae6cc","title":"타이탄의 도구들 - 오늘도 대담하게 뛰어들었는가 (브레네 브라운 편)","slug":"tools-of-the-titan-daring-to-dive-in-today-with-brene-brown","category":"book","releaseDate":"2024-02-06T00:00+09:00","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/2tdFjwXUKVthYWcggOennK/9aced5e340200859036905dab1ce4282/Screenshot_2024-02-06_at_12.50.55_PM.png"},"contents":{"childMarkdownRemark":{"html":"<blockquote>\n<p>휴스턴 대학교 사회복지학과의 브레네 브라운<em>Brene Brown, @BreneBrown</em> 박사는 '역대 가장 많은 사람이 본 테드<em>TED</em> 강연 영상 5개' 중 하나의 소유자다. 2010년 '취약성의 힘'이라는 주제로 열린 그녀의 강연 영상은 3,100만 건이 넘는 조회 수를 기록했다. 그녀는 지난 13년간 취약성과 용기, 가치, 수치심 등에 대해 연구했고, &#x3C;마음 가면> &#x3C;불완전함의 선물> &#x3C;라이징 스트롱> 등의 베스트셀러를 펴냈다.</p>\n<p><strong>두려움과 용기는 늘 함께 다닌다</strong>\n그녀는 이렇게 말했다. \"용감하거나 겁쟁이거나, 사람은 이 둘 중 하나라는 말은 사실이 아니다. 우리는 모두 두려움을 느끼는 동시에 용기를 내기 때문이다.\"\n나는 복싱 선수 마이크 타이슨의 전설적인 코치였던 쿠스 다마토Cus D'Amato가 큰 경기를 앞두고 선수들에게 했다는 말이 떠올랐다. \"영웅과 겁쟁이는 똑같은 것을 느낀다. 하지만 영웅은 자신의 두려움을 상대 선수에게 던져버린다. 반면에 겁쟁이는 이를 피해 도망친다. 두 사람이 느끼는 건 모두 두려움이다. 그 두려움을 어떻게 써먹느냐가 승패를 결정한다.\"</p>\n<p><strong>당신은 경기장에 서 있는 투사인가?</strong>\n젊은 시절, 브레네는 우연히 시어도어 루스벨트 대통령이 남긴 유명한 '경기장에 선 투사'라는 연설을 접하게 되었다. 살아가면서 상처가 되는 모든 공격과 비판에 직면한다 할지라도, 내가 옳다고 생각한 신념과 가치를 포기하지 않겠노라 굳게 결심한 것이다.\n그렇다면 궁금해진다. 그녀의 삶에 터닝 포인트를 제공한 '경기장에 선 투사'란 어떤 의미인가? 그녀는 이렇게 말했다. \"이 세상에서 가장 중요한 사람은 경기장에 선 투사다. 그는 얼굴에 흙먼지와 땀과 피를 잔뜩 묻혀가며 용감하게 싸운다. 실책을 범하고 거듭 한계에 부딪치기도 한다. 그가 누구인 줄 아는가? 바로 나, 그리고 당신이다.\"\n더 나은 사람이 되려면 우리는 실수와 한계를 드러내는 일에 두려움을 갖지 않아야 한다. 가장 많은 실수를 드러내는 사람이 '가장 열심히 노력하는 사람'이다. 그러니 그것들을 보여주는 건 자랑스러운 일이지, 부끄러워 할 이유가 아니다.\n브레네는 계속 설명한다. \"경기장의 투사로 살면 확실하게 보장받는 것이 있다. '흠씬 두들겨 맞을 것'이라는 사실이다. 정신 없이 두들겨 맞을 것을 알면서도 대담하게 뛰어드는 것, 그것이 우리가 가져야 할 단 하나의 삶이다. 인생을 바꿀 만한 커다란 용기는 '흠씬 두들겨 맞을 것이다'와 같은 '취약성'을 드러내고 감수할 때 생겨난다. 우리는 매일 두 개의 질문을 던져야 한다. '나는 오늘 대담하게 뛰어들었는가?' '나는 편암함 대신 용기를 선택하기 위해 어떤 취약성을 드러내고 감수했는가?'\"\n이는 아침 일기나 저녁 일기를 쓸 때 하루를 돌아보게 해주는 매우 좋은 질문들이다. 그녀의 이 메시지는 3,000만 명이 시청한 강연을 만들어냈다. \"테드<em>TED</em> 강연을 위해 내가 준비한 것은 내 취약성을 드러내며 대담하게 뛰어드는 것이 전부였다. 나는 내 자신의 다양한 실패에 대해 이야기했다. 심리 상담을 받고 돌아가는 길에 두 번 다시는 받지 않겠노라 결심한 이야기도 했다. 관객들은 경기장에 선 나에게 큰 박수를 보내주었다. 그리고 깨달았다. 강연이 끝났을 때 어지럽고 속이 울렁거리지 않으면, 그건 대담하게 뛰어들지 않았다는 뜻이라는 것을.\"</p>\n<p><strong>상대에게 도와줄 기회를 제공하라</strong>\n취약성은 이제 더 이상 숨겨야 할 것이 아니다. 솔직하게 드러낸 취약성은 사람들에게 신뢰를 심어주는 훌륭한 도구다. 흔히 상대에게 단단한 신뢰를 먼저 얻고 난 다음에 자신의 취약성을 드러내야 한다고 생각한다. 하지만 먼저 나의 연약함, 취약함을 드러내지 않으면 시간이 흘러도 신뢰관계는 형성되지 않는다.\n브레네는 마지막으로 이렇게 말했다.\n\"인생은 결코 편안하게 흘러가지 않는다. 생각해보라. 편안하게 얻은 게 하나라도 있는지를. 뭔가를 얻으려면 빈틈이 없는, 매끄러운 사람이 되어선 안된다. 그런 사람에게 사람들이 귀를 기울이고 칭찬할 것 같은가? 천만에다. 속이 울렁거리고 얼굴이 화끈거려 몹시 불편하더라도 기꺼이 먼저 자신의 취약한 부분을 드러내는 사람을 세상은 더 높게 평가하고 도와준다. 상대에게 도움의 기회를 제공하는 사람이 가장 용감하게, 가장 빠르게 성공한다.\"</p>\n</blockquote>\n<p><a href=\"https://www.ted.com/talks/brene_brown_the_power_of_vulnerability\">브레네 브라운의 \"취약성의 힘\" (테드 영상)</a></p>","excerpt":"휴스턴 대학교 사회복지학과의 브레네 브라운Brene Brown, @BreneBrown 박사는 '역대 가장 많은 사람이 본 테드TED 강연 영상 5개' 중 하나의 소유자다. 2010년 '취약성의 힘'이라는 주제로 열린 그녀의 강연 영상은 3,10…"}},"tag":["타이탄의도구들","브레네브라운"]},{"id":"508d4194-6f87-5a11-84d7-3c440965d612","title":"homebrew mysql 설치 및 사용자 생성 과정 (MAC M1)","slug":"homebrew-install-mysql-create-user","category":"tech","releaseDate":"2024-02-01T00:00+09:00","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/5uY5dUEJATe35jDUi8xFgp/5b1fef7f57c26b83f9be5521bca7376d/DALL_E_2024-02-01_11.19.59_-_Create_a_flowchart_representing_the_process_of_managing_MySQL_users_on_a_server._The_flowchart_.png"},"contents":{"childMarkdownRemark":{"html":"<h3 id=\"mysql-설치-및-실행\" style=\"position:relative;\"><a href=\"#mysql-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%A4%ED%96%89\" aria-label=\"mysql 설치 및 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>mysql 설치 및 실행</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-shell line-numbers\"><code class=\"language-shell\"><span class=\"token comment\"># 설치 (현재 기준 8.3.0 버전)</span>\n$ brew <span class=\"token function\">install</span> mysql\n\n<span class=\"token comment\"># 실행</span>\n$ brew services start mysql\n\n<span class=\"token comment\"># 로그인</span>\n$ mysql <span class=\"token parameter variable\">-u</span> root</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"로그인-시-mysqlsock-에러가-발생한다면\" style=\"position:relative;\"><a href=\"#%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%8B%9C-mysqlsock-%EC%97%90%EB%9F%AC%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%9C%EB%8B%A4%EB%A9%B4\" aria-label=\"로그인 시 mysqlsock 에러가 발생한다면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>로그인 시 mysql.sock 에러가 발생한다면?</h3>\n<p>Can't connect to local MySQL server through socket '/tmp/mysql.sock'</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-shell line-numbers\"><code class=\"language-shell\">$ <span class=\"token builtin class-name\">cd</span> /opt/homebrew/Cellar/mysql/8.3.0/support-files\n$ mysql.server start</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"사용자-생성-mysql-console\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%83%9D%EC%84%B1-mysql-console\" aria-label=\"사용자 생성 mysql console permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용자 생성 (mysql console)</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-sql line-numbers\"><code class=\"language-sql\"><span class=\"token comment\"># localhost 만 허용</span>\nmysql<span class=\"token operator\">></span> <span class=\"token keyword\">create</span> <span class=\"token keyword\">user</span> <span class=\"token string\">'newuser'</span><span class=\"token variable\">@'localhost'</span> identified <span class=\"token keyword\">by</span> <span class=\"token string\">'password'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># 모든 호스트 허용</span>\nmysql<span class=\"token operator\">></span> <span class=\"token keyword\">create</span> <span class=\"token keyword\">user</span> <span class=\"token string\">'newuser'</span><span class=\"token variable\">@'%'</span> identified <span class=\"token keyword\">by</span> <span class=\"token string\">'password'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># 권한 부여</span>\nmysql<span class=\"token operator\">></span> <span class=\"token keyword\">grant</span> <span class=\"token keyword\">all</span> <span class=\"token keyword\">privileges</span> <span class=\"token keyword\">on</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">to</span> <span class=\"token string\">'newuser'</span><span class=\"token variable\">@'localhost'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># 사용자 삭제</span>\nmysql<span class=\"token operator\">></span> <span class=\"token keyword\">drop</span> <span class=\"token keyword\">user</span> <span class=\"token string\">'newuser'</span><span class=\"token variable\">@'localhost'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># 변경 사항 적용</span>\nmysql<span class=\"token operator\">></span> flush <span class=\"token keyword\">privileges</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>","excerpt":"mysql 설치 및 실행 로그인 시 mysql.sock 에러가 발생한다면? Can't connect to local MySQL server through socket '/tmp/mysql.sock' 사용자 생성 (mysql console)"}},"tag":["mysql","homebrew"]},{"id":"74d9feca-c272-59ee-99e5-4be889c33cf3","title":"Stable Diffusion WebUI 실행하기 (Apple Silicon)","slug":"stable-diffusion-webui-apple-silicon","category":"tech","releaseDate":"2024-01-27T00:00+09:00","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/Me3Rz6NjY33WRlw0VVUGe/1e9e4f9890bc7e450c087399747fe866/DALL_E_2024-01-27_14.10.15_-_A_scene_depicting_a_group_of_people_gathered_around_a_-Stable_Diffusion_WebUI-_setup._The_peopl.png"},"contents":{"childMarkdownRemark":{"html":"<p><strong>레퍼런스</strong>\n<a href=\"https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Installation-on-Apple-Silicon\">https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Installation-on-Apple-Silicon</a></p>\n<h3 id=\"실행방법\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%ED%96%89%EB%B0%A9%EB%B2%95\" aria-label=\"실행방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실행방법</h3>\n<p>아래는 python 이 설치되어 있다는 가정하에 작성된 명령들입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-shell line-numbers\"><code class=\"language-shell\"><span class=\"token comment\">## 소스 다운로드</span>\n$ <span class=\"token builtin class-name\">cd</span> ~/Documents/Project/\n$ <span class=\"token function\">git</span> clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git\n$ <span class=\"token builtin class-name\">cd</span> stable-diffusion-webui\n\n<span class=\"token comment\">## virtual 환경 실행</span>\n$ python3 <span class=\"token parameter variable\">-m</span> venv ./env\n$ <span class=\"token builtin class-name\">source</span> env/bin/activate\n\n<span class=\"token comment\">## 패키지 설치</span>\n$ pip <span class=\"token function\">install</span> <span class=\"token parameter variable\">-r</span> requirements.txt</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>상단 레퍼런스의 <a href=\"https://huggingface.co/runwayml/stable-diffusion-v1-5/resolve/main/v1-5-pruned-emaonly.ckpt\">v1-5-pruned-emaonly.ckpt 링크</a> 혹은 <a href=\"https://huggingface.co/runwayml/stable-diffusion-v1-5\">허깅페이스</a>에서 ckpt 파일을 다운로드한 다음 models/Stable-diffusion 디렉토리에 옮겨주고 루트경로에서 아래 명령을 실행합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-shell line-numbers\"><code class=\"language-shell\">$ <span class=\"token function\">mv</span> ~/Downloads/v1-5-pruned-emaonly.ckpt ./models/Stable-diffusion\n$ ./webui.sh</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><a href=\"http://127.0.0.1:7860/\">http://127.0.0.1:7860/</a> 경로의 웹페이지가 자동으로 열리는데 다운로드한 모델을 선택하고 프롬프트를 입력한 다음 Generate 를 클릭하면 이미지가 생성됩니다.</p>\n<h3 id=\"실행결과\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%ED%96%89%EA%B2%B0%EA%B3%BC\" aria-label=\"실행결과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실행결과</h3>\n<p><img src=\"//images.ctfassets.net/vpyfljks33op/6uKBsmzrUQk1Pp3W43eIZx/6f42d15dbba3bc022f456de159cfbe0f/Screenshot_2024-01-27_at_1.43.43_PM.png\" alt=\"Stable Diffusion WebUI\"></p>","excerpt":"레퍼런스\nhttps://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Installation-on-Apple-Silicon 실행방법 아래는 python…"}},"tag":["Stable Diffusion","WebUI"]},{"id":"6bbfc04a-4c30-5b5c-b876-a5cd6e43b85c","title":"요즘 것들의 사생활 - episode 01 서른의 퇴사, 1년간의 직업 실험 _ with 김가현","slug":"privacy-of-things-these-days-episode-01","category":"book","releaseDate":"2024-01-24T00:00+09:00","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/5NgUMd6wkKpTDOKoC3logA/e8a2cfffbc901ddef3adc4d2b8624000/Screenshot_2024-01-24_at_12.26.16_PM.png"},"contents":{"childMarkdownRemark":{"html":"<blockquote>\n<p><em>나에게 1년 정도 시간을 줬던 거네요. 그 시간 동안 다양한 직업 실험을 했다면서요? 맨 처음 하게 된 일은 어떤 거였어요?</em>\n맨 처음 하게 된 일이 프리랜서로 웹 기획하는 거였어요. 내가 회사 안에서 쌓아온 그 기술이 회사 밖에서도 팔릴지 너무 확인하고 싶었거든요.</p>\n<p><em>개발자와 대화하기 위해서 밤을 새우면서 통화 녹취를 풀고 공부하며 쌓은 그 기술이요? 어떻던가요?</em>\n한참 잘 먹고 잘 살았죠. (웃음) 시간당 페이가 높더라고요. 되게 쏠쏠한 직업이었죠.</p>\n<p><em>그 시간이 헛되지 않았네요.</em>\n정말, 정말 헛되지 않았더라고요. (웃음)</p>\n<p><em>그런 일을 시작으로 어떤 것들을 하며 먹고살았어요?</em>\n프리랜서 웹 기획자를 시작으로, 콘텐츠 제작자로 일하기도 하고, 강사로 강연을 하기도 했고요. 바리스타가 돼서 커피를 내리는 일도 했고, 문화 기획자가 돼서 1박 2일짜리 행사를 만들기도 했어요.</p>\n<p><em>되게 다양한 일을 했네요. 회사에서 했던 일과는 무척 다르고 전공과도 상관없는 완전히 새로운 일이 많았던 것 같은데, 이런 실험을 한 이유는 뭐였나요?</em>\n내가 어디까지 할 수 있는지, 그걸로 돈이 벌리는지 알고 싶었어요. 그래서 최대한 겹치지 않는 일들을 하려고 했던 것 같아요.</p>\n<p><em>그중에 제일 재미있었던 일은 뭐였어요?</em>\n강원도에서 제 또래 청년들을 만나는 일이었어요. 거기서 자기 나름대로 일과 삶의 균형을 맞춰가면서 <strong>어떻게 먹고사는 일을 해결하는지</strong> 인터뷰하는 프로젝트를 직접 기획해서 진행했었는데요. 저는 평생 서울에서만, 그러니까 굉장히 자원이 집중된 환경에서 살아왔단 말이에요. 근데 강원도만 해도 인적 자원과 물적 자원이 서울과 굉장히 달라요. <strong>그런 환경에서 나랑 비슷한 사람들이 먹고사는 일을 해결하고 있더라고요, 자기 나름대로.</strong> 그걸 보는 일이 굉장히 재밌었어요. 신선했고, 영감을 많이 받았고, 그 사람들이 또 나의 동료가 되기도 했고요. 강원도를 왔다 갔다 하면서 내가 그동안 얼마나 좁은 울타리에서 살았나, 얼마나 좁은 가능성만을 생각하면서 살았나, 하는 생각을 했던 것 같아요.</p>\n<p><em>나에게 맞는 일을 좀 찾은 것 같나요?</em>\n직업 실험에서 가장 흥미로웠던 것은, 진짜 나답지 않은 일을 했을 때 더 많이 성장하고 가능성이 열리고 더 많은 영감을 얻었다는 거였어요.</p>\n<p><em>어떤 것에 의존하지 않고 스스로 먹고살 수 있는 힘을 기르는 건 좋지만, 그걸 계속하기 위해서는 지속 가능한 수익 구조도 있어야 된다고 생각하거든요. 혹시 그런 부분에서 구체적인 계획이 있나요?</em>\n사실 이 실험을 계획할 때는 지속 가능한 수익이 저의 고려 사항은 아니었어요. 왜냐하면 그때는 회사에서 매달 받는 월급이 저한테는 지속 가능한 수익이었으니, 그게 갖고 싶으면 퇴사하지 말아야 한다고 생각했죠. 그런데 지금 생각해보면 그 월급이라는 것도 사실은 지속가능하지 않다고 느껴지거든요. 우리는 입사해서 정년퇴임을 하는 그런 시대에 살고 있지 않잖아요. 월급이라는 것도 결국에 회사가 주고싶을 때까지만 이어지는 그런 돈이라고 생각하거든요. 그러면 지금 단계에서 나는 <strong>지속가능한 수익을 만들 게 아니라 지속 가능한 나, 어떤 변화에도 적응하는 나, 어떤 일 앞에서도 맥락을 갖추는 나, 내가 하는 일을 설명할 수 있고, 왜 하고 있는지 알고 있는 나를 만드는 게 더 중요하고 그게 지금 내 단계에서 해야 할 일이라고 생각했어요.</strong> 여하튼 365일을 살아냈잖아요. 그럼 이젠 내가 먹고사는 걸 해결하기 위해서 만든 돈을 조금 더 많이, 조금 더 꾸준히 벌 수 있는 방법을 고민하는 게 이 다음 단계에 저한테 놓인 숙제겠죠.</p>\n</blockquote>","excerpt":"나에게…"}},"tag":["김가현","요즘것들의사생활"]},{"id":"ddeedeaf-9aad-5fac-bd93-5a7f08d69bc7","title":"내 생애 단 한번 / 장영희","slug":"once-in-a-lifetime-jangyounghee","category":"book","releaseDate":"2024-01-19T00:00+09:00","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/rUcdBqBWD3I6GBgOUwE95/edb131e89bcb28c84279333e85de86e2/Screenshot_2024-01-19_at_7.19.55_PM.png"},"contents":{"childMarkdownRemark":{"html":"<blockquote>\n<p>\"깨어지기 쉽고, 날카로운 모서리를 갖고 있고, 또는 너무 비싸서 아주 조심스럽게 다루어야 하는 장난감은 진짜가 될 수 없어. 진짜가 될 즈음에는 대부분 털은 다 빠져 버리고 눈도 없어지고 팔다리가 떨어져 아주 남루해 보이지. 하지만 그건 문제 되지 않아. 왜냐하면 진짜는 항상 아름다운 거니까.\"</p>\n</blockquote>\n<blockquote>\n<p>짝사랑이란 삶에 대한 강렬한 참여의 한 형태이다. 충만한 삶에는 뚜렷한 참여 의식이 필요하고, 거기에는 환희뿐만 아니라 고통 역시 수반하게 마련이다. 우리 삶에 있어서의 다른 모든 일들처럼 사랑도 연습을 필요로 한다.</p>\n<p>그리고 짝사랑이야말로 성숙의 첩경이고 사랑 연습의 으뜸이다. 학문의 길도 어쩌면 외롭고 고달픈 짝사랑의 길이다. 안타깝게 두드리며 파헤쳐도 대답 없는 벽 앞에서 끝없는 좌절감을 느끼지만, 그래도 포기하지 않고 끝까지 나아가는 자만이 마침내 그 벽을 허물고 좀더 넓은 세계로 나갈 수 있는 승리자가 된다.</p>\n<p>그러므로 젊은이들이여, 당당하고 열정적으로 짝사랑하라. 사람을 사랑하고, 신을 사랑하고, 학문을 사랑하고, 진리를 사랑하고, 저 푸른 나무 저 높은 하늘을 사랑하고, 그대들이 몸담고 있는 일상을 열렬히 사랑하라.</p>\n<p>사랑에 익숙지 않은 옹색한 마음이나 사랑에 '통달'한 게으른 마음들을 마음껏 비웃고 동정하며 열심히 사랑하라. 눈앞에 보이는 보상에 연연하여, 남의 눈에 들기 위해 자신을 버리는 사랑의 거지가 되지 말라.</p>\n<p>창 밖의 젊은이들을 보며 나도 다시 한번 다짐한다. '불혹'의 편안함보다는 여전히 짝사랑의 고뇌를 택하리라고. 내가 매일 대하는 저 아름다운 청춘들을 한껏 질투하며 나의 삶을, 나의 학문을, 나의 학생들을 더욱 더 열심히 혼신을 다해 짝사랑하리라.</p>\n</blockquote>\n<blockquote>\n<p>이 책에서 내가 개인적으로 제일 좋아하는 말은 노인이 죽은 물고기를 지키기 위해 혼신을 다해 상어와 싸우며 하는 말, \"희망을 갖지 않는 것은 어리석다. 희망을 버리는 것은 죄악이다 <em>It is silly not to hope. It is a sin</em> \"라는 말이다.</p>\n<p>삶의 요소요소마다 위험과 불행은 잠복해 있게 마련인데, 이에 맞서 '파괴될지언정 패배하지 않는' 불패의 정신으로 하루하루를 살아가는 것은 참으로 숭고하다. 그러나 희망이 없다면 그 싸움은 너무나 비장하고 슬프다. 지금의 고통이 언젠가는 사라지리라는 희망, 누군가 어둠 속에서 손을 뻗어 주리라는 희망, 내일은 내게 빛과 생명이 주어지리라는 희망, 그런 희망이 있어야 우리의 투혼도 빛나고, 노인이 물고기에 대해 느끼는 것과 같은 삶에 대한 동지애도 생긴다. 그리고 그런 희망을 가지지 않는 것은 죄이다. 빛을 보고도 눈을 감아 버리는 것은 자신을 어둠의 감옥 속에 가두어 버리는 자살 행위와 같기 때문이다.</p>\n</blockquote>\n<blockquote>\n<p>살아가면서 누군가를 미워할 때 그를 '용서해야 할 이유'보다는 '용서하지 못할 이유'를 먼저 찾고, 누군가를 비난하면서 그를 '좋아해야 할 이유'보다는 '좋아하지 못할 이유'를 먼저 찾고, 마음의 문을 꽁꽁 닫아건 채 누군가를 '사랑해야 할 이유'보다는 '사랑하지 못할 이유'를 먼저 찾지는 않았는지.</p>\n<p>나는 '구심' 병을 손에 꼭 쥐고 하느님께 용서를 빌었다.</p>\n<p>\"주님, 제 육체 속의 심장은 멀쩡히 뛰고 있지만 제 마음이 병들었나이다. 제 마음을 고쳐 주소서. 저에게 '구심<em>救心</em>'의 은총을 베푸시어 희고 깨끗한 마음을 주소서.\"</p>\n</blockquote>\n<blockquote>\n<p>&#x3C;주홍 글씨>라는 소설에서 너새니얼 호손은 이 세상에서 가장 '용서받지 못할 죄<em>unpardonable sin</em>'는 다른 사람의 '마음의 성역'을 침범하는 일이라고 말했다.</p>\n</blockquote>","excerpt":"…"}},"tag":["장영희","내생애단한번"]},{"id":"11176eab-27a1-51d6-ad9c-c4f7431ef325","title":"지식인의 서재 / 한정원","slug":"intellectuals-library-hanjungwon","category":"book","releaseDate":"2024-01-16T00:00+09:00","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/35PQuVZJ70TjgRHPakCbuU/ae3f2d644c555b79e03344dab390195d/Screenshot_2024-01-16_at_2.50.39_PM.png"},"contents":{"childMarkdownRemark":{"html":"<blockquote>\n<p>\"글을 쓰는 게 중요한 게 아니고 글쓰기를 통해서 이 세상의 모든 사물들이 귀하다는 것을 깨닫게 되는 거야. 왜냐하면 세상을 자세히 보아야 글을 쓸 수 있거든. 자세히 본 것을 쓰다 보면 더욱 자세히 보여. 그러면 급속도로 발전이 돼지. 정신적으로 풍요해지는 거야. 글쓰기가 중요한 이유는 세상 사람들에게 드러나는 모든 것이 글이기 때문이야. 자기 분야에서 앞서가는 사람들은 모두 글을 써. 글을 쓰기 때문에 앞서가는 거야. 글쓰기란 세상을 보는 눈을 갖게 하고 그것을 표현하는 힘을 주지.\" (김용택)</p>\n</blockquote>\n<blockquote>\n<p>집안이 나쁘다고 탓하지 말라.\n나는 아홉 살 때 아버지를 잃고 마을에서 쫓겨났다.\n가난하다 말하지 말라.\n나는 들쥐를 잡아먹으며 연명했고,\n목숨을 건 전쟁이 내 직업이고 내 일이었다.\n작은 나라에서 태어났다고 말하지 말라.\n그림자 말고는 친구도 없고,\n병사로만 10만, 백성은 어린애, 노인까지 합쳐 2백만 명도 되지 않았다.\n배운 게 없다고, 힘이 없다고 탓하지 말라.\n나는 내 이름도 쓸 줄 몰랐으나\n남의 말에 귀 기울이면서\n현명해지는 법을 배웠다.\n너무 막막하다고 그래서 포기해야겠다고 말하지 말라.\n나는 목에 칼을 쓰고도 탈출했고\n뺨에 화살을 맞고 죽었다 살아나기도 했다.\n적은 바깥에 있는 것이 아니라 내 안에 있었다.\n나는 내게 거추장스러운 것을 모두 깡그리 쓸어버렸다.\n나를 극복하는 순간,\n나는 징기스칸이 되었다.</p>\n</blockquote>\n<blockquote>\n<p>그녀(김진애)가 꿈꿔온 인생은 자신의 스케쥴을 자신의 의지대로 행하며 사는 것이다. 그리고 그녀는 지금 야성을 가지고 속도감을 즐기며 살고 있다.\n\"젋음의 특권은 실패입니다. 저는 실패한 게 훨씬 더 많아요. 실패를 한다는 것은 아주 중요한 경험이죠. 온몸을 던지고 나야 실패도 다가오니까요. 깨져보는 건 젊을 때 해봐야 돼요. 그래야 클 수 있어요.\"</p>\n</blockquote>\n<blockquote>\n<p>그(이주헌)는 미술책을 읽다가 어려워 읽기 힘들거든 책에서 글을 빼고 그림만 보라고 했다. 그리고 '자기 내면의 소리에 집중하라'고 했다. 다른 사람들의 평가나 이야기에 좌우되지 말고 자신의 느낌을 지휘하라는 것이다. 예술에 감동할 줄 아는 사람은 책을 읽을 때나 사람과 대화할 때 내용의 본질을 받아들이는 깊이가 다르다. 책을 통해서, 예술을 통해서 감성을 기른 사람은 아주 작은 것에도 기쁨을 맛보고 행복을 느낀다. 그렇게 자주 행복과 충만함을 느끼게 되면 어려움 속에서도 삶에 대해 불평하기보다는 감사하게 된다. 그런 삶을 살고 싶지 않은가?</p>\n</blockquote>","excerpt":"…"}},"tag":["한정원","지식인의서재"]}]},"allContentfulGallery":{"nodes":[{"id":"acc8b799-b877-556e-b6dd-293edf60bb77","title":"Symphonies In Bloom","slug":"symphonies-in-bloom-dalle","category":"ai","author":"DALL·E","headerImage":{"url":"https://images.ctfassets.net/vpyfljks33op/4Mcr8ILNO9fNXqTbn609L5/1107ed43eea505a789d63454775889c6/1709003466311g_800x800.webp"},"contents":{"childMarkdownRemark":{"html":"<p>Generate an image of a delicate, vibrant watercolor painting featuring a large, central rose flower with soft pink and light blue petals, surrounded by smaller wildflowers and a variety of greenery. The background should be a soft wash of whites and pale blues with artistic splashes of yellow and pink watercolor droplets scattered around, suggesting a loose, airy feel. The composition should be slightly off-center, with it being the main focus and the smaller blooms and foliage creating an asymmetrical balance. The style should capture the essence of a spontaneous and expressive watercolor garden scene, with a sense of freshness and natural beauty.</p>","excerpt":"Generate an image of a delicate, vibrant watercolor painting featuring a large, central rose flower with soft pink and light blue petals…"}},"tag":null}]},"allContentfulQuote":{"nodes":[{"id":"a9fd5482-6bbd-5c78-96ac-4dae6d283686","title":"지란지교를 꿈꾸며","slug":"dreaming-of-jiranjigyo-yoo-an-jin","author":"유안진","category":"poem","content":{"childMarkdownRemark":{"excerpt":"…","html":"<p>저녁을 먹고 나면 허물없이 찾아가\n차 한잔을 마시고 싶다고 말할 수 있는\n친구가 있었으면 좋겠다.</p>\n<p>입은 옷을 갈아입지 않고\n김치 냄새가 좀 나더라도\n흉보지 않을 친구가\n우리집 가까이에 있었으면 좋겠다.</p>\n<p>비 오는 오후나 눈 내리는 밤에\n고무신을 끌고 찾아가도 좋을 친구\n밤늦도록 공허한 마음도\n마음놓고 보일 수 있고\n악의 없이 남의 얘기를 주고받고 나서도\n말이 날까 걱정되지 않는 친구가...</p>\n<p>사람이 자기 아내나 남편,\n지 형제나 제 자식하고만 사랑을 나눈다면\n어찌 행복해질 수 있으랴.\n영원이 없을수록 영원을 꿈꾸도록\n서로 돕는 진실한 친구가 필요하리라.</p>\n<p>그가 여성이어도 좋고 남성이어도 좋다.\n나보다 나이가 많아도 좋고\n동갑이거나 적어도 좋다.\n다만 그의 인품이 맑은 강물처럼\n조용하고 은근하며 깊고 신선하며\n예술과 인생을 소중히 여길 만큼\n성숙한 사람이면 된다.</p>\n<p>그는 반드시 잘 생길 필요도 없고\n수수하나 멋을 알고\n중후한 몸가짐을 할 수 있으면 된다.</p>\n<p>때로 약간의 변덕과 신경질을 부려도\n그것이 애교로 통할 수 있을 정도면 괜찮고\n나의 변덕과 괜한 흥분에도 적절히 맞장구 쳐 주고 나서\n얼마의 시간이 흘러 내가 평온해지거든\n부드럽고 세련된 표현으로\n충고를 아끼지 않았으면 좋겠다.</p>\n<p>나는 많은 사람을 사랑하고 싶진 않다.\n많은 사람과 사귀기도 원치 않는다.\n나의 일생에 한 두 사람과 끊어지지 않는\n아름답고 향기로운 인연으로\n죽기까지 지속되길 바란다.</p>\n<p>나는 여러 나라 여러 곳을 여행하면서,\n끼니와 잠을 아껴 될수록 많은 것을 구경하였다.\n그럼에도 지금은 그 많은 구경 중에\n기막힌 감회로 남는 것은 거의 없다.\n만약 내가 한두 곳 한두 가지만\n제대로 감상했더라면,\n두고두고 되새길 자산이 되었을 걸.</p>\n<p>우정이라 하면 사람들은 관포지교를 말한다.\n그러나 나는 친구를 괴롭히고 싶지 않듯이\n나 또한 끝없는 인내로 베풀기만 할 재간이 없다.\n나는 도 닦으며 살기를 바라지 않고,\n내 친구도 성현 같아지기를 바라진 않는다.\n나는 될수록 정직하게 살고 싶고,\n내 친구도 재미나 위안을 위해서\n그저 제자리서 탄로나는 약간의 거짓말을 하는\n재치와 위트를 가졌으면 싶을 뿐이다.</p>\n<p>나는 때로 맛있는 것을 내가 더 먹고 싶을 테고,\n내가 더 예뻐 보이기를 바라겠지만,\n금방 그 마음을 지울 줄도 알 것이다.\n때로 나는 얼음 풀리는 냇물이나\n가을 갈대숲 기러기 울음을\n친구보다 더 좋아할 수 있겠으나,\n결국은 우정을 제일로 여길 것이다.</p>\n<p>우리는 흰눈 속 참대 같은 기상을 지녔으나\n들꽃처럼 나약할 수 있고,\n아첨 같은 양보는 싫어하지만\n이따금 밑지며 사는 아량도 갖기를 바란다.\n우리는 명성과 권세, 재력을 중시하지도\n부러워하지도 경멸하지도 않을 것이며,\n그보다는 자기답게 사는데\n더 매력을 느끼려 애쓸 것이다.</p>\n<p>우리가 항상 지혜롭진 못하더라도,\n자기의 곤란을 벗어나기 위해\n비록 진실일지라도 타인을 팔진 않을 것이다.\n오해를 받더라도 묵묵할 수 있는\n어리석음과 배짱을 지니기를 바란다.\n우리의 외모가 아름답진 않다 해도\n우리의 향기만은 아름답게 지니리라.</p>\n<p>우리는 시기하는 마음 없이\n남의 성공을 얘기하며,\n경쟁하지 않고 자기 일을 하되,\n미친 듯 몰두하게 되길 바란다.\n우리는 우정과 애정을 소중히 여기되\n묵숨을 거는 만용은 피할 것이다.\n그래서 우리의 우정은 애정과도 같으며\n우리의 애정 또한 우정과도 같아서\n요란한 빛깔과 시끄러운 소리도 피할 것이다.</p>\n<p>나는 반닫이를 닦다가\n그를 생각할 것이며,\n화초에 물을 주다가,\n안개 낀 아침 창문을 열다가,\n가을 하늘의 흰 구름을 바라보다가,\n까닭없이 현기증을 느끼다가\n문득 그가 보고 싶어지며\n그도 그럴 때 나를 찾을 것이다.</p>\n<p>그는 때로 울고 싶어지기도 하겠고,\n내게도 울 수 있는 눈물과\n추억이 있을 것이다.\n우리에겐 다시 젊어질 수 있는 추억이 있으나,\n늙는 일에 초조하지 않을\n웃음도 만들어 낼 것이다.</p>\n<p>우리는 눈물을 사랑하되 헤프지 않게\n가지는 멋보다 풍기는 멋을 사랑하며,\n냉면을 먹을 때는 농부처럼 먹을 줄 알며,\n스테이크를 자를 때는 여왕보다 품위있게,\n군밤을 아이처럼 까먹고,\n차를 마실때는 백작부인보다 우아해지리라.</p>\n<p>우리는 푼돈을 벌기 위해\n하기 싫은 일을 하지 않을 것이며,\n천년을 늙어도 항상 가락을 지니는 오동나무처럼,\n일생을 춥게 살아도 향기를 팔지 않은 매화처럼,\n자유로운 제 모습을 잃지 않고\n살고자 애쓰며 서로 격려하리라.</p>\n<p>우리는 누구도 미워하지 않으며,\n특별히 한 두 사람을 사랑한다 하여\n많은 사람을 싫어하진 않으리라.\n우리가 멋진 글을 못쓰더라도\n쓰는 일을 택한 것을 후회하지 않듯이,\n남의 약점도 안쓰럽게 여기리라.</p>\n<p>내가 길을 가다가 한 묶음 꽃을 사서 그에게 안겨줘도,\n그는 날 주착이라고 나무라지 않으며,\n건널목이 아닌 데로 찻길을 건너도\n나의 교양을 비웃지 않을 게다.\n나 또한 더러 그의 눈에 눈꼽이 끼더라도,\n이 사이에 고춧가루가 끼었다 해도\n그의 숙녀됨이나 그의 신사다움을 의심치 않으며,\n오히려 인간적인 유유함을 느끼게 될 게다.</p>\n<p>우리의 손이 작고 여리나\n서로를 버티어 주는 기둥이 될 것이며,\n우리의 눈에 핏발이 서더라도\n총기가 사라진 것은 아니며,\n눈빛이 흐리고 시력이 어두워질수록\n서로를 살펴주는 불빛이 되어주리라.</p>\n<p>그러다가 어느 날이 홀연히 오더라도 축복처럼\n웨딩드레스처럼 수의를 입게 되리라.\n같은 날 또는 다른 날이라도 .\n세월이 흐르거든 묻힌 자리에서\n더 고운 품종의 지란이 돋아 피어,\n맑고 높은 향기로 다시 만나지리라.</p>"}}}]}},"pageContext":{}},"staticQueryHashes":["3507440187"],"slicesMap":{}}